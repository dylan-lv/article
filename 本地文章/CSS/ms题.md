### 1、防止父元素高度坍塌的 4 种方案

问题重现：

- 父元素的高度，都是由内部未浮动子元素的高度撑起的。
- 如果**子元素浮动**起来，就**不占用普通文档流**的位置。**父元素高度**就会**失去支撑**，也称为**高度坍塌**。



**不好的解决方法**

- ~~给父元素设置固定高度~~

缺点：多数情况下，父元素高度由内容撑起，很难提前固定父元素的高度。



**方案1：**（经过测试，只能解决 float引起的坍塌问题，不能解决绝对定位的坍塌问题）

为父元素设置 **overflow: hidden** 属性。

原理：CSS 中 **overflow: hidden** 属性会强制要求父元素必须包裹住所有内部浮动的元素，以及所有元素的 margin 范围

缺点：如果刚好父元素有些超范围的子元素内容需要显示（比如，个别 position 定位的子菜单项），不想隐藏，就会发生冲突。



**方案2：**

在父元素内的结尾追加一个空子元素（块级元素），并设置空子元素清除浮动影响（clear: both）。

原理：利用 clear: both 属性和父元素必须包含非浮动的元素两个原理

缺点：无端多出一个无意义的但不见的空元素，**影响选择器和查找元素**。



**方案3：**

设置父元素也浮动。

原理：浮动属性也会强制父元素扩大到包含所有浮动的内部元素。

缺点：会**产生新的浮动影响**。比如，父元素浮动，导致父元素之后平级的页脚div上移，被父元素挡住了。



**方案4：（最好做法）**

为父元素末尾伪元素设置 clear: both

在元素开头的结尾各有一个伪元素：`::before` 和 `::after` 。

优点：既不会影响显示隐藏，又不会影响查找元素，又不会产生新的浮动问题。

```css
.parent::after{ content: ""; display: block; clear: both; height: 0; } // 有些游览器display有默认高度
```



### 2、BFC

- 什么是BFC（Block formatting context）
- 直译为 “块级格式化上下文”
- 它是网页中一个 **独立的渲染区域**（也称为 formatting context）
- 这个渲染区域**只有块级（Block）元素才能参与**。
- 它规定了内部的块级元素如何布局
- BFC渲染区域内部如何布局，与区域外部毫不相干
- 外部元素也不会影响BFC渲染区域内的元素



简单来说：BFC就是页面上的一个隔离的**独立渲染区域**。

区域里面的子元素不会影响到外面的元素。

外面的元素也不会影响到区域里面的子元素。



**css两种渲染区域**：块级元素渲染区域和行级元素渲染区域。

- BFC（Block formatting context）
  - 块级渲染区域：所有 display 属性为 `block， list-item，table ` 的元素，会生成块级元素渲染区域。
  - 块级元素渲染区域内以 BFC 方式渲染。
- IFC（inline formatting context）
  - 行级元素渲染区域：display属性为 `inline，inline-block，inline-table` 的元素，会生成行级元素渲染区域。 
  - 行级元素渲染区域以 IFC 方式渲染



#### BFC的布局规则

- 属于同一个BFC的两个相邻块元素在垂直方向上的 margin 会发生重叠/合并。但水平方向的 margin 不会
- 左侧 BFC 渲染区域的 margin，必须与右侧 BFC 渲染区域的 margin 相衔接，不能出现重叠。



#### 4种情况下会形成BFC渲染区域

- float 的值不是 none
- position 的值不是 static 或者 relative
- display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex
- overflow 的值不是 visible



#### BFC解决问题

**问题1**：垂直方向上，两个元素上下 margin 相遇时，两元素间的总间距并不等于两个 margin 的和。而是等于最大的 margin。（小的会被大的吞并）

解决：

- 用一个外围块元素包裹下方元素
- 父元素设置样式 `::before{ content: ""; display: table; height: 0; }`

原理：新的外层元素，变成一个BFC方式的渲染区域，就必须包裹内部子元素及子元素的 margin。而且，内部元素不能超出范围影响外部，外部元素也不能进入 BFC 范围内，影响内部



**问题2：**垂直方向的margin溢出。子元素设置 margin-top，会超出父元素上边的范围，变成父元素的 margin-top，而实际上，子元素与父元素之间，依然是没有margin-top的。

**解决方法：5种**

- 设置父元素 overflow: hidden
  - bfc的方式
- 为父元素添加上边框，颜色设置为透明（transparent）
  - 原理：这里不是bfc。而是因为边框本身可以阻隔 margin 溢出
  - 缺点：会增大父元素的实际大小，导致布局错乱
- 用父元素的 padding-top 代替第一个子元素的 margin-top
- 在父元素内第一个子元素之前添加一个空的 `<table></table>`
  - 原理：table的display属性默认相当于 table，所以形成小的 bfc 渲染区域。
  - 优点：空 table 元素没有大小，不占用父元素空间
  - 缺点：增加了一个看不见的空元素，干扰查找元素
- 伪类：`父元素::before{ content: ""; display: table; }`



**问题3**：左侧定宽，右侧自适应

第一步：左侧定宽元素左浮动：`.left{ float: left; width: 200px }`

第二步：右侧元素不用右浮动，而是 `.right{ overflow: hidden; }`

原理：右边元素 overflow: hidden 后，形成 BFC 渲染区域。左边的 float 元素就不能进入右边范围了。



### 3、弹性布局

优点：自动计算，自适应；弹性布局可**自动计算**宽度、间距等，使多个元素始终保持最初设计的样子。



### 4、居中的方法

前提：父元素必须是块级盒子容器；父元素宽度必须已经被设定好。

不可自由嵌套的元素：就是里面只能放内联元素的，包括

- 标题标记：h1、h2、h3、h4、h5、h6、caption
- 段落标记：p
- 分割线：hr
- 一个特别的元素 `<dt>`，它只存在于列表元素 `<dl>` 的子一级
- 例如：p元素里不可嵌套 h，解析出来会是 p标签、h标签、p标签 三个，而且是平级关系



#### 场景1：

父元素是块级元素，子元素也是块级元素，但宽度没有设定。

不用考虑，因为子元素会占满整行。



#### 场景2：

子元素是行内元素，子元素宽度是由其内容撑开的。

这种情况下解决方案是给父元素设定：`text-align: center;`



#### 场景3：

子元素是块级元素且宽度已经设定。

**方案一：**给子元素添加 `margin: 0 auto;`

**方案二**：父元素相对定位，子元素绝对定位

- 子元素：`left: 50%;`
- 子元素：`margin-left: 子元素宽一半;` 或者 `transform: translateX(-50%);`

**方案三**：`display: flex; flex-direction: row; justify-content: center;`



### 5、垂直居中

前提：父元素是盒子容器

#### 场景1：

子元素是行内元素，高度是由其内容撑开的。

单行：设定其父元素的 `line-height` 为其高度使得子元素垂直居中。

多行：通过给父元素设定 `display: inline / inline-blick / table-cell; vertical-align: middle;` 来解决。  

注意：vertical-align 一般情况下，table-cell 这种行内元素才可以用



#### 场景2：

子元素是块级元素，但子元素高度没有设定

**方案一**：通过给父元素设定 `display: inline / inline-blick / table-cell; vertical-align: middle;` 来解决。  

**方案二**：flexbox。父元素：`display: flex; flex-direction: column; justify-content: center;`



### 6、移动端适配问题

简述 rpx、px、em、rem、%、vh、vw的区别



#### pt：设备物理像素

屏幕宽 / 分辨率，其中每一小份就是 1 pt



#### px：css像素

pc机大屏幕显示器：1px约等于0.76分物理像素

手机小屏幕：以 iPhone6 为标准，物理像素750，分辨率 375。1px = 2pt

所以，px也是一个相对单位

手机屏幕大小不一，差异较大，所以，反而不希望一个元素在所有手机上显示一样大。而是希望能够等比缩放。



#### rem

以网页根元素 `<html>` 元素上设置的默认字体大小为 1rem。默认 1rem = 16px；

好处：

- 可以实现响应式布局
- 响应式布局指的是元素大小能根据屏幕大小随时变化
- 因为，所有以 rem 为单位的位置、大小都跟着根元素字体大小而变化
- 所以只要在屏幕大小变化的时候改变根元素 font-size 就行了。



#### em

父元素的字体大小为 1em：用的不多



#### rpx：小程序专用



### 7、响应式布局的方式，几种，媒体查询原理

`<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">`中每个属性的含义

**viewport**：视口，显示设备内部，真正实际可用于显示网页的区域大小。

**width**：视口宽，device-width（等于物理设备宽）

**user-scalable**：是否允许用户手动缩放网页

**initial-scale=1.0**：加载页面时，页面的缩放比例是1，表示不缩放，原网页大小展示

**maximum-scale/minimum-scale**：允许用户缩放网页的最大和最小缩放比例，都是 1，表示不允许用户使用过程中，中途缩放网页



#### 5种响应式布局方式

**flex布局**

优点：代码简单，布局方便

缺点：

- 如果中间有内容，缩到最小就不会再小了（因为里面的字不能再小了）
- 且左右侧的宽度变小了



**父相子绝**

优点：结合使用 media 可以实现响应式布局

缺点：

- 代码写法复杂，布局较繁琐
- 如果不适用 media 平分屏幕，宽度小于 600 的情况下，右侧会覆盖左侧。



**grid布局**

- Flex布局是轴线布局，只能指定 “项目” 针对轴线的位置，可以看做是一维布局
- Grid 布局则是将容器划分成 “行” 和 “列” ，产生单元格，然后指定 “项目所在” 的单元格，可以看做是二维布局
- Grid布局远比 Flex 布局强大。（不过存在兼容性问题）
- 知识点比较多，学习成本相对较高，目前兼容性不如 flex 布局



**float布局**

容易被挤压



**rem作为单位，等比缩放**















































