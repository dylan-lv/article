<a href="https://leetcode-cn.com/problems/combinations/" target="_blank">组合</a>

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1：**

```js
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**示例 2：**

```js
输入：n = 1, k = 1
输出：[[1]]
```



### 思路

直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。

代码如下：

```js
let res = [], n = 4;
for(let i=1; i<=n; i++) {
  for(let j=i+1; j<=n; j++) {
    res.push([i, j])
  }
}
console.log(res)
```

如果n为100，k为50呢，那就是50层for循环，是不是开始窒息。

此时就会发现虽然想暴力搜索，但是用for循环嵌套连暴力都写不出来。

**回溯法**

要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题。

递归来做层叠嵌套（可以理解是开k层for循环），每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了。

此时递归的层数大家应该知道了，例如：n为100，k为50的情况下，就是递归50层。

把组合问题抽象为如下树形结构：

<img src="./assets/回溯3.png" alt="回溯3" />

- 可以看出这个棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不在重复取。

- 第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。

- 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。
- 图中可以发现n相当于树的宽度，k相当于树的深度。
- 图中每次搜索到了叶子节点，我们就找到了一个结果。

相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。

```js
var combine = function(n, k) {
  let result = []; // 存放符合条件结果的集合
  backtrack(1, []); // 从1开始，此时的路径为空
  return result;
  
  function backtrack(start, path) {
    if(path.length === k) {
      result.push([...path]); // array是引用类型，这里对其进行拷贝一份，以免被后面的path变化波及
      return;
    }
    // 从开始的数字到末尾的数字
    for(let i=start; i<=n; i++) {
      path.push(i); // 加入选择列表中
      backtrack(i+1, path); // 继续深度搜索
      path.pop(); // 撤销选择
    }
  }
};
```



### 剪枝优化

回溯法虽然是暴力搜索，但有时候也可以剪枝优化一下的。

在遍历的过程中有如下代码：

```js
for(let i=start; i<=n; i++) {
  path.push(i);
  backtrack(i+1, path);
  path.pop();
}
```

这个遍历的范围是可以剪枝优化的。

举个例子，n=4，k=4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。在第二层for循环，从元素3开始的遍历都没有意义了。

如图所示：

<img src="./assets/回溯4.png" alt="回溯4" />

图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。

所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。

如果for循环选择的起始位置之后的元素个数**已经不足**我们需要的元素个数了，那么就没必要搜索了。

注意代码中 i ，就是for循环里选择的起始位置。

```js
for(let i=start; i<=n; i++)
```

接下来看一下优化过程：

1. 已经选择的元素个数：path.length
2. 还需要的元素个数：k - path.length
3. 在集合 n 中至多要从该起始位置开始遍历：n - (k - path.length) + 1

为什么要有个 + 1 呢，因为包括起始位置，我们需要一个左闭的集合。

举个例子，n=4，k=3，目前已经选取的元素为0个，n+(0 - k) + 1 即 4 + ( 0 - 3 ) + 1 = 2

从 2 开始搜索都是合理的，可以是组合 [ 2, 3, 4 ]

优化后整体代码如下：

```js
var combine = function(n, k) {
    let result = []; // 存放符合条件结果的集合
    backtrack(1, []); // 从1开始，此时的路径为空
    return result;
    
    function backtrack(start, path) {
        if(path.length === k) {
            result.push([...path]); // array是引用类型，这里对其进行拷贝一份，以免被后面的path变化波及
            return;
        }
        // 从开始的数字到末尾的数字
        for(let i=start; i<=n + (path.length - k) + 1; i++) {
            path.push(i); // 加入选择列表中
            backtrack(i+1, path); // 继续深度搜索
            path.pop(); // 撤销选择
        }
    }
};
```



