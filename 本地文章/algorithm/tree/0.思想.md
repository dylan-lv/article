# Tree

二叉树遍历框架

```js
function traverse(root) {
  // 前序遍历
  traverse(root.left);
  // 中序遍历
  traverse(root.right);
  // 后序遍历
}
```



## 一、二叉树的重要性

经典算法【快速排序】和【归并排序】中，快速排序就是二叉树的前序遍历，归并排序就是二叉树的后序遍历。



### 快速排序

快速排序的逻辑是：若要对 `nums[l0 ... ln]` 进行排序，我们先找一个分界点 `p`，通过交换元素使得 `nums[l0 ... p-1]` 都小于等于 `nums[p]`，且 `nums[p+1 ... ln]` 都大于 `nums[p]`，然后递归地去 `nums[l0 ... p-1]` 和 `nums[p+1 ... ln]` 中寻找新的分界点，最后整个数组就被排序了。

代码框架如下：

```js
function sort(nums, l, r) {
  /* 前序遍历位置 */
  // 通过交换元素构建分界点 p
  let p = partition(nums, l, r);
  
  sort(nums, l, p-1);
  sort(nums, p+1, r);
}
```

先构造分界点，然后去左右子数组构造分界点，这不就是一个二叉树的前序遍历吗？



### 归并排序

若要对 `nums[l ... r]` 进行排序，我们先对 `nums[l ... mid]` 排序，再对 `nums[mid+1 ... r]` 排序，最后把这两个有序的子数组合并，整改数组就排好序了。

代码框架如下：

```js
function sort(nums, l, r) {
  let mid = Math.floor((l + r) / 2);
  sort(nums, l, mid);
  sort(nums, mid+1, r); 
  /* 后序遍历位置 */
  
  // 合并两个排好序的子数组
  merge(nums, l, mid, r);
}
```

先对左右子数组排序，然后合并（类似合并有序链表的逻辑）



## 二、写递归算法的秘诀

写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。

怎么理解呢，我们用一个具体的例子来说，比如说让你计算一棵二叉树共有几个节点：

```js
// 定义：count(root) 返回以 root 为根的树有多少节点
function count(root) {
  if(!root) return 0;
  // 自己加上子树的节点数就是整棵树的节点数
  return 1 + count(root.left) + count(root.right);
}
```

写树相关的算法，简单说就是，先搞清楚当前 `root` 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调用子节点，递归调用会让孩子节点做相同的事情。

所谓「该做什么」就是让你想清楚写什么代码能够实现题目想要的效果，所谓「什么时候做」，就是让你思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上。











































