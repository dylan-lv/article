# Tree

二叉树遍历框架

```js
function traverse(root) {
  // 前序遍历
  traverse(root.left);
  // 中序遍历
  traverse(root.right);
  // 后序遍历
}
```



## 一、二叉树的重要性

经典算法【快速排序】和【归并排序】中，快速排序就是二叉树的前序遍历，归并排序就是二叉树的后序遍历。



### 快速排序

快速排序的逻辑是：若要对 `nums[l0 ... ln]` 进行排序，我们先找一个分界点 `p`，通过交换元素使得 `nums[l0 ... p-1]` 都小于等于 `nums[p]`，且 `nums[p+1 ... ln]` 都大于 `nums[p]`，然后递归地去 `nums[l0 ... p-1]` 和 `nums[p+1 ... ln]` 中寻找新的分界点，最后整个数组就被排序了。

代码框架如下：

```js
function sort(nums, l, r) {
  /* 前序遍历位置 */
  // 通过交换元素构建分界点 p
  let p = partition(nums, l, r);
  
  sort(nums, l, p-1);
  sort(nums, p+1, r);
}
```

先构造分界点，然后去左右子数组构造分界点，这不就是一个二叉树的前序遍历吗？



### 归并排序

若要对 `nums[l ... r]` 进行排序，我们先对 `nums[l ... mid]` 排序，再对 `nums[mid+1 ... r]` 排序，最后把这两个有序的子数组合并，整改数组就排好序了。

代码框架如下：

```js
function sort(nums, l, r) {
  let mid = Math.floor((l + r) / 2);
  sort(nums, l, mid);
  sort(nums, mid+1, r);
  /* 后序遍历位置 */
  
  // 合并两个排好序的子数组
  merge(nums, l, mid, r);
}
```

先对左右子数组排序，然后合并（类似合并有序链表的逻辑）

















































