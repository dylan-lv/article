## 安装

使用vite搭建项目

```bash
npm init @vitejs/app
npm install
```

安装vue-router和vuex

```bash
npm i vue-router@next vuex@next -S
```



## 规范

先对几个文件夹的分层进行规定，便于管理，下面是 src 目录的组织结构。

```js
├── src
│   ├── api            数据请求
│   ├── assets         静态资源
│   ├── components     组件
│   ├── pages          页面
│   ├── router         路由配置
│   ├── store          vuex数据
│   └── utils          工具函数
```

我们的页面需要引入路由系统，我们进入到 router 文件夹中，新建 index.js，写入下面的代码：

```js
import { createRouter, createWebHashHistory } from "vue-router";
import Home from '../pages/home.vue';
import About from '../pages/about.vue';

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home,
  },
  {
    path: '/about',
    name: 'About',
    component: About,
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router;
```

在 main.js 中，加载 router 的配置

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router/index'

createApp(App)
  .use(router)  
  .mount('#app')
```

然后修改App.vue文件

```vue
<template>
  <div>
    <router-link to="/">home</router-link>
    <router-link to="/about">about</router-link>
  </div>
  <router-view></router-view>
</template>
```



在 src 下的 components 目录，新建一个 Todolist.vue ，并在这个文件里写出下面的代码：

```vue
<template>
  <h1 @click="add">{{ count }}</h1>
</template>

<script setup>
import { ref } from 'vue';
let count = ref(1);
function add() {
  count.value++;
}

</script>

<style>
h1{
  color: red;
}
</style>
```

然后再Home组件中引入Todolist

```vue
<template>
  <h1>home</h1>
  <TodoList />
</template>

<script setup>
import TodoList from '../components/Todolist.vue'
</script>
```



## TodoList组件

修改TodoList组件

```vue
<template>
  <input type="text" v-model="title" @keydown.enter="addTodo">
  <ul v-if="todos.length">
    <li v-for="(todo, index) in todos" :key="index">
      <input type="checkbox" v-model="todo.done">
      <span :class="{ done: todo.done }">{{ todo.title }}</span>
    </li>
  </ul>
</template>

<script setup>
import { ref } from 'vue';
let title = ref("");
let todos = ref([
  { title: '学习Vue', done: false }
])

function addTodo() {
  todos.value.push({
    title: title.value,
    done: false,
  })
  title.value = "";
}

</script>
```



### 计算属性

在 Composition API 的语法中，计算属性和生命周期等功能，都可以脱离 Vue 的组件机制单独使用 。我们向 TodoList.vue 代码块中加入下面的代码：

```vue
<template>
  <input type="text" v-model="title" @keydown.enter="addTodo">
  <button v-if="active < all" @click="clear">清理已完成项</button>
  <ul v-if="todos.length">
    <li v-for="(todo, index) in todos" :key="index">
      <input type="checkbox" v-model="todo.done">
      <span :class="{ done: todo.done }">{{ todo.title }}</span>
    </li>
  </ul>
  <div v-else>暂无数据</div>
  <div>
    全选
    <input type="checkbox" v-model="allDone">
    <span>{{ active }} / {{ all }}</span>
  </div>
</template>

<script setup>
import { computed, ref } from 'vue';
let title = ref("");
let todos = ref([
  { title: '学习Vue', done: false }
])

function addTodo() {
  todos.value.push({
    title: title.value,
    done: false,
  })
  title.value = "";
}
function clear() {
  todos.value = todos.value.filter(v => !v.done);
}

let active = computed(() => {
  return todos.value.filter(v => !v.done).length;
})
let all = computed(() => todos.value.length)
let allDone = computed({
  get: function() {
    return active.value === 0;
  },
  set: function(value) {
    todos.value.forEach(todo => {
      todo.done = value;
    })
  }
})

</script>
```



### Composition API 拆分代码

所有功能代码都写在一起的话，也会带来一些问题：随着功能越来越复杂，script 内部的代码也会越来越多。因此，我们可以进一步对代码进行拆分，把功能独立的模块封装成一个独立的函数，真正做到按需拆分。

在下面，我们新建了一个函数 useTodos：

```js
function useTodos() {
  let title = ref("");
  let todos = ref([{ title: '学习Vue', done: false }]);

  function addTodo() {
    todos.value.push({
      title: title.value,
      done: false,
    })
    title.value = "";
  }
  function clear() {
    todos.value = todos.value.filter(v => !v.done);
  }

  let active = computed(() => {
    return todos.value.filter(v => !v.done).length;
  })
  let all = computed(() => todos.value.length)
  let allDone = computed({
    get: function() {
      return active.value === 0;
    },
    set: function(value) {
      todos.value.forEach(todo => {
        todo.done = value;
      })
    }
  })
  return { title, todos, addTodo, clear, active, all, allDone };
}
```



这个函数就是把那些和清单相关的所有数据和方法，都放在函数内部定义并且返回，这样这个函数就可以放在任意的地方来维护。

而我们的组件入口，也就是 `<script setup>` 中的代码，就可以变得非常简单和清爽了。在下面的代码中，我们只需要调用 useTodos，并且获取所需要的变量即可，具体的实现逻辑可以去 useTodos 内部维护，代码可维护性大大增强。

```vue
<script setup>
import { computed, ref } from 'vue';

let count = ref(1);
function add() {
  count.value++
}

let { title, todos, addTodo, clear, active, all, allDone } = useTodos();
</script>
```

我们在使用 Composition API 拆分功能时，也就是执行 useTodos 的时候，ref、computed 等功能都是从 Vue 中单独引入，而不是依赖 this 上下文。其实你可以把组件内部的任何一段代码，从组件文件里抽离出一个独立的文件进行维护。



**示例：获取鼠标位置**

```vue
import {ref, onMounted, onUnmounted} from 'vue'

export function useMouse(){
	const x = ref(0);
	const y = ref(0);
	function update(e) {
		x.value = e.pageX;
		y.value = e.pageY;
	}
	onMounted(() => {
		window.addEventListener('mousemove', update);
	})
	onUnmounted(() => {
		window.removeEventListener('mousemove', update);
	})
	return { x, y };
}
```

完成了上面的鼠标事件封装这一步之后，我们在组件的入口就可以和普通函数一样使用 useMouse 函数。在下面的代码中，上面的代码返回的 x 和 y 的值可以在模板任意地方使用，也会随着鼠标的移动而改变数值。

```js
import { useMouse } from '../utils/mouse';
let { x, y } = useMouse();
```

相信到这里，你一定能体会到 Composition API 对代码组织方式的好处。简单来看，因为 ref 和 computed 等功能都可以从 Vue 中全局引入，所以我们就可以把组件进行任意颗粒度的拆分和组合，这样就大大提高了代码的可维护性和复用性。





















