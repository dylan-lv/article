## effect，reactive（依赖收集 触发依赖）

现在，我们开始写第一个测试。可以把之前初始化项目使用的测试文件给删掉 `src\reactivity\tests\index.spec.ts`。

新建文件 `src\reactivity\tests\effect.spec.ts`

先放入核心测试流程

```ts
describe("effect", () => {
  // 核心代码逻辑
  it("happy path", () => {
    const user = reactive({
      age: 10,
    });

    let nextAge;
    // user.age：依赖收集
    // effect一上来会直接调用fn，然后会触发 user.age 的get操作，触发get时进行依赖收集
    effect(() => {
      nextAge = user.age + 1;
    });
    expect(nextAge).toBe(11);

    // 更新：触发依赖
    // 触发依赖：user.age触发set操作时，会把所有收集到的fn拿出来调用一下
    user.age++;
    expect(nextAge).toBe(12);
  });
});
```

可以看出这个测试代码里面实际上会涉及到两部分内容，一部分是 `reactive`，一部分是 `effect`，这里可以把它拆开，分步骤实现。这里体现了**任务拆分**的思想。



### 步骤1：reactive

先来编写 `reactive` 的测试用例：`src\reactivity\tests\reactive.spec.ts`

```ts
describe("reactive", () => {
  it("happy path", () => {
    const original = { foo: 1 };
    const observed = reactive(original);
    // 他俩绝对是不相等的
    expect(observed).not.toBe(original);
    // observed.foo 应该是 original.foo 的值
    expect(observed.foo).toBe(1);
  });
});
```

测试用例写好了，我们来实现 reactive

> 首先，我们应该先在 tsconfig.json 中修改 lib，"lib": ["DOM", "ES6"]。否则 Proxy 会报错

新建文件 `src\reactivity\reactive.ts`

```ts
export function reactive(raw) {
  return new Proxy(raw, {
    get(target, key) {
      const res = Reflect.get(target, key)
      
      // TODO 依赖收集
      return res;
    },
    set(target, key, value) {
      const res = Reflect.set(target, key, value);

      // TODO 触发依赖
      return res;
    }
  })
}
```

我们先不做**依赖收集**和**触发依赖**。

此时，控制台输入命令：`yarn test reactive`，即可看到 `reactive` 的测试用例通过了。



### 步骤2：effect





















